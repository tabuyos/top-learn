 多线程会引起数据不一致的问题
 Synchronized
 Volatile
 单例
 锁
    悲观锁：写（增删改）多， 读（查）少 lock， 写的时候多， 就容易引起数据不一致
    乐观锁：读多， 写少 版本控制



 CAS
    CompareAndSwap
    一种无锁的原子算法， 乐观锁
    基本思想：
        给你一个期望值， 与你现有的值比较， 如果相等在修改， 不想等什么事都不做， CAS(V, E, N) V=E > N=T, V!=E > N=F
        CAS实现稍微复杂，但是他是无所的机制， 没有加锁和解锁的操作， 因此提高了效率， 提高了CPU的吞吐量， 不存在阻塞
        性能好
    volatile 可以保证可见性和有序性， 但是不能保证原子性
    应用场景
        应用于简单的数据计算
        适合线程冲突少的场景
    缺点:
        ABA问题  无法检测到中间值的变化(解决方法 AtomicStampedReference)
